; Для массива из 12 16-разрядных чисел со знаком 
; разработать блок-схему алгоритма, программу на языке ассемблера 
; и в машинных кодах микропроцессора К1810ВМ86, 
; которая сортирует массив слов на четные и нечетные. 
; А также:
; располагает четные числа в порядке убывания модуля,
; располагает нечетные числа в порядке возрастания модуля,
; рассчитывает среднее арифметическое всех чисел, кратных 3.
; http://www.avprog.narod.ru/progs/emu8086/8086_instruction_set.html
 
 
ORG 100h                     ; начальный адрес программы

;array DW 004D2h, 0162Eh, 02334h, 00D80h, 0E12Eh, 0F6D7h, 01538h, 02694h, 010E1h, 0223Dh, 0F7C3h, 0E58Bh
array DW 0DDDDh, 0BCDAh, 0BCDFh, 012A3h, 0574Fh, 00000h, 01357h, 08888h, 01337h, 04488h, 0228Ch, 0DEF1h

                       
count_even DW 0              ; количество четных элементов
addres_array_even DW 00010h  ; адрес для записи четных элементов
index_array_even DW 0        ; индекс текущего чеnного элемента массива
                
count_odd DW 0               ; количество нечетных элементов
addres_array_odd DW 00030h   ; адрес для записи нечетных элементов 
index_arrar_odd DW 0         ; индекс текущего нечетного элемента массива

count_value_3 DW 0           ; количество чисел, которые делятся на 3
addres_value_sum_3 DW 00050h ; адрес для записи суммы чисел     
 
start:                
    MOV SI, 0             ; индекс текущего элемента массива
    MOV BP, 0             ; адрес начала массива  
    MOV CX, 12            ; количество значений в массиве     
    OUTPUT:   
        MOV AX, array[SI] ; загрузка числа для проверки в регистр AX 
        TEST AX, 1        ; проверка на четность
        JNZ NUMBER_ODD    ; переход, если число нечетное   (ZF=0)
        JZ NUMBER_EVEN    ; переход, если число четное (ZF=1)          

    NUMBER_ODD:                     ; если число четное
         MOV DI, [index_arrar_odd]  ; записываем в DI значение индекса массива для четных
         MOV BP, [addres_array_odd] ; записываем в BP адресс массива для четных 
         MOV [BP+DI], AX            ; сохранение четного числа в массиве   
         ADD SI, 2                  ; переход к следующему элементу массива
         INC [count_odd]            ; увеличение количества четных чисел  
         ADD [index_arrar_odd], 2   ; увеличиваем индекс след значения массива для четных
    LOOP OUTPUT                     ; переходим в метку OUTPUT ЕСЛИ CX != 0
    JCXZ NEXT_ARRAY_SORT        ; если CX = 0, то идем дальше
      
    NUMBER_EVEN:                     ; если число нечетное
         MOV DI, [index_array_even]  ; записываем в DI значение индекса массива для нечетных
         MOV BP, [addres_array_even] ; записываем в BP адресс массива для нечетных   
         MOV [BP+DI], AX             ; сохранение четного числа в массиве   
         ADD SI, 2                   ; переход к следующему элементу массива
         INC [count_even]            ; увеличение количества четных чисел  
         ADD [index_array_even], 2   ; увеличиваем индекс след значения массива для нечетных
    LOOP OUTPUT                      ; переходим в метку OUTPUT ЕСЛИ CX != 0 
    JCXZ NEXT_ARRAY_SORT         ; если CX = 0, то идем дальше

NEXT_ARRAY_SORT:
; ===============================     
; SORT ARRAY ODD
; ===============================

MOV AX, [count_odd]    
MOV [00001h], AX 
DEC [00001h]                    ; заносим в память, количество нечетных чисел
MOV BX, 0                       ; внешний счетчик цикла
MOV BP, [addres_array_odd]      ; адрес массива
LOOOP_START_ODD:
    CMP BX, [00001h]            ; сравниваем внешний счетчик
    JGE EXIT_SORT_ODD           ; если счетчик дошел до предпоследнего индекса, то выйти
    MOV CX, [00001h]            ; внести в счетчик количество элементов
    SUB CX, BX                  ; вычитаем из счетчика количество пройденых внешних циклов
    MOV SI, 0                   ; индекс секушего элемента 
    MOV DX, 0                   ; флаг, который нужен чтобы знать была перестановка или нет
    
    LOOP_SORT_ODD:
        MOV AX, [BP+SI]         ; занечти в AX элемент массива  
        CMP AX, [BP+SI+2]       ; сравнить значение в AX со следующим элементом массива
        JNA NO_SWAP_ODD         ; если значение меньше или равно, то пропускаем перестановку
        XCHG AX, [BP+SI+2]      ; меняем местами два операнда
        MOV [BP+SI], AX         ; заносим значение
        MOV DX, 1               ; ставим значение 1, тоесть перестановка было
        NO_SWAP_ODD:
        ADD SI, 2               ; прибавляем к индексу 2, чтобы перейти к след значению
        LOOP LOOP_SORT_ODD      ; если CX не закончился, перейти в LOOP_SORT_ODD
    INC BX                      ; прибавить к внешнему счетчику 1 LOOP_SORT_ODD
    CMP DX, 0                   ; если не было перестановок, то массив отсортирован, и можно выйти
    JE EXIT_SORT_ODD
    JMP LOOOP_START_ODD         ; перейти в LOOOP_START_ODD 
EXIT_SORT_ODD:

;
; ===============================     
; SORT ARRAY EVEN
; ===============================
      
MOV AX, [count_even]    
MOV [00001h], AX 
DEC [00001h]                    ; заносим в память, количество четных чисел
MOV BX, 0                       ; внешний счетчик цикла
MOV BP, [addres_array_even]      ; адрес массива
LOOOP_START_EVEN:
    CMP BX, [00001h]            ; сравниваем внешний счетчик
    JGE EXIT_SORT_EVEN          ; если счетчик дошел до предпоследнего индекса, то выйти
    MOV CX, [00001h]            ; внести в счетчик количество элементов
    SUB CX, BX                  ; вычитаем из счетчика количество пройденых внешних циклов
    MOV SI, 0                   ; индекс секушего элемента 
    MOV DX, 0                   ; флаг, который нужен чтобы знать была перестановка или нет
    
    LOOP_SORT_EVEN:
        MOV AX, [BP+SI]         ; занечти в AX элемент массива  
        CMP AX, [BP+SI+2]       ; сравнить значение в AX со следующим элементом массива
        JNBE NO_SWAP_EVEN       ; если значение больше или равно, то пропускаем перестановку
        XCHG AX, [BP+SI+2]      ; меняем местами два операнда
        MOV [BP+SI], AX         ; заносим значение
        MOV DX, 1               ; ставим значение 1, тоесть перестановка было
        NO_SWAP_EVEN:
        ADD SI, 2               ; прибавляем к индексу 2, чтобы перейти к след значению
        LOOP LOOP_SORT_EVEN     ; если CX не закончился, перейти в LOOP_SORT_EVEN
    INC BX                      ; прибавить к внешнему счетчику 1 LOOP_SORT_EVEN
    CMP DX, 0                   ; если не было перестановок, то массив отсортирован, и можно выйти
    JE EXIT_SORT_EVEN
    JMP LOOOP_START_EVEN        ; перейти в LOOOP_START_EVEN 
EXIT_SORT_EVEN:

; ЭТО РАБОТАЕТ
; ===============================     
; AVG VALUE 3
; ===============================  
MOV SI, 0                        ; индекс текущего элемента массива
MOV BP, [addres_value_sum_3]     ; адрес где находится сумма значений  
MOV CX, 12                       ; количество значений в массиве  
MOV BX, 3                        ; пишем в BX его делитель    
AVG_OUTPUT:   
    MOV AX, array[SI]            ; загрузка числа для проверки в регистр AX 
    MOV DX, 0                    ; очищаем регистр DX
    TEST AX, 08000h              ; проверяем число отрицательное или нет
    JZ NO_NEGATIVE               ; если положительное, то пропускаем
    MOV DX, 0FFFFh               ; добавляем в DX -1, чтобы DX:AX было отрицательным
    NO_NEGATIVE:
    IDIV BX                      ; делим DX:AX на BX(3)
    CMP DX, 0                    ; проверяем есть ли остаток или нет
                       
    JNE NO_SUM3                  ; если остаток есть, то пропускаем часть, где заносим число
    INC [count_value_3]          ; прибавляем единицу счетчик   
    MOV DI, [addres_value_sum_3] ; записываем адрес памяти, в которой будет находится сумма всех чисел которые делятся на 3
    MOV AX, array[SI]            ; загрузка числа для проверки в регистр AX
    ADD [DI], AX                 ; суммируем число чтобы в памяти была сумма всех чисел которые делятся на 3 
    NO_SUM3:
    ADD SI, 2                    ; переход к следующему элементу массив 
LOOP AVG_OUTPUT
    
        
MOV AX, 0                       ; обнуляем регистры
MOV BX, 0                       ; обнуляем регистры
MOV BP, [addres_value_sum_3]    ; записываем в BP адрес где находится вся сумма значений
MOV AX, [BP]                    ; записываем в AX значения из адреса 
MOV DX, 0  

TEST AX, 08000h                 ; проверяем число отрицательное или нет
JZ NO_NEGATIVE_IDIV             ; если положительное, то пропускаем
MOV DX, 0FFFFh                  ; добавляем в DX -1, чтобы DX:AX было отрицательным
NO_NEGATIVE_IDIV: 

MOV BX, [count_value_3]         ; записываем в BX количесвто этих значений
CMP BX, 0                       ; сравниваем количество с нулем
JE NO_IDIV_AVG                  ; если количество = 0, то пропускаем деление (на ноль делить нельзя)
IDIV BX                         ; делим сумму всех значений на количество
NO_IDIV_AVG:

HLT    
END

