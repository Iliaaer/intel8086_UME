; Для массива из 12 16-разрядных чисел со знаком 
; разработать блок-схему алгоритма, программу на языке ассемблера 
; и в машинных кодах микропроцессора К1810ВМ86, 
; которая сортирует массив слов на четные и нечетные. 
; А также:
; располагает четные числа в порядке убывания модуля,
; располагает нечетные числа в порядке возрастания модуля,
; рассчитывает среднее арифметическое всех чисел, кратных 3.
; http://www.avprog.narod.ru/progs/emu8086/8086_instruction_set.html
 
 
ORG 100h                     ; начальный адрес программы

array DW 2, -4, 1, -1, -6    ; массив для проверки         
len_array DW 5               ; размер массива
                       
count_even DW 0              ; количество четных элементов
addres_array_even DW 00010h  ; адрес для записи четных элементов
index_array_even DW 0        ; индекс текущего чеnного элемента массива
                
count_odd DW 0               ; количество нечетных элементов
addres_array_odd DW 00020h   ; адрес для записи нечетных элементов 
index_arrar_odd DW 0         ; индекс текущего нечетного элемента массива

count_value_3 DW 0           ; количество чисел, которые делятся на 3
addres_value_sum_3 DW 0F0F0h ; адрес для записи суммы чисел
MOV [0F0F0h], 0
 
start:                
    MOV SI, 0             ; индекс текущего элемента массива
    MOV BP, 0             ; адрес начала массива  
    MOV CX, [len_array]   ; количество значений в массиве    
    
    MOV BL, 3             ; делитель 3, на что надо проверить   
    OUTPUT:   
        MOV AX, array[SI] ; загрузка числа для проверки в регистр AX
        
        IDIV BL           ; делим число со знаком на 3
        CMP AH, 0         ; проверяем есть ли остаток или нет
        MOV AX, array[SI] ; записать число кторое мы проверяем назад 
        JE SUM_3          ; если число делится на 3, то переходим в местку (ZF=1)       
         
        GO_NEXT_OUTPUT: 
        
        TEST AX, 1        ; проверка на четность
        JNZ NUMBER_ODD    ; переход, если число нечетное   (ZF=0)
        JZ NUMBER_EVEN    ; переход, если число четное (ZF=1)      
    

    NUMBER_ODD:                     ; если число четное
         MOV DI, [index_arrar_odd]  ; записываем в DI значение индекса массива для четных
         MOV BP, [addres_array_odd] ; записываем в BP адресс массива для четных 
         MOV [BP+DI], AX            ; сохранение четного числа в массиве   
         ADD SI, 2                  ; переход к следующему элементу массива
         INC [count_odd]            ; увеличение количества четных чисел  
         ADD [index_arrar_odd], 2   ; увеличиваем индекс след значения массива для четных
    LOOP OUTPUT                     ; переходим в метку OUTPUT ЕСЛИ CX != 0
    JCXZ NEXT_ARRAY_SORT_ODD        ; если CX = 0, то идем дальше
      
    NUMBER_EVEN:                     ; если число нечетное
         MOV DI, [index_array_even]  ; записываем в DI значение индекса массива для нечетных
         MOV BP, [addres_array_even] ; записываем в BP адресс массива для нечетных   
         MOV [BP+DI], AX             ; сохранение четного числа в массиве   
         ADD SI, 2                   ; переход к следующему элементу массива
         INC [count_even]            ; увеличение количества четных чисел  
         ADD [index_array_even], 2   ; увеличиваем индекс след значения массива для нечетных
    LOOP OUTPUT                      ; переходим в метку OUTPUT ЕСЛИ CX != 0 
    JCXZ NEXT_ARRAY_SORT_ODD         ; если CX = 0, то идем дальше
    
    SUM_3:                            ; если делится на 3
        INC [count_value_3]          ; прибавляем единицу счетчик 
        MOV DI, [addres_value_sum_3] ; записываем адрес памяти, в которой будет находится сумма всех чисел которые делятся на 3
        ADD [DI], AX                 ; суммируем число чтобы в памяти была сумма всех чисел которые делятся на 3   
    JMP GO_NEXT_OUTPUT               ; Переход на метку без условия


; ===============================     
; SORT ARRAY ODD
; ===============================

NEXT_ARRAY_SORT_ODD:    
MOV CX, [count_odd]             ; количество значений в массиве 
CMP CX, 0                       ; сравнивает количество значений в массиве с 0
JE NO_LOOP_ODD:                 ; если количество = 0, то пропускаем сортировку
MOV DX, 1                       ; счетчикдо какого элемента массива можно идти (с конца)
LOOP1_ODD:
    MOV BX, 0                   ; проверка на то, была ли перестановка или нет
    MOV SI, 0                   ; индекс текущего элемента массива
    MOV BP, [addres_array_odd]  ; адрес начала массива      
    LOOP2_ODD:
        MOV [01111h], CX
        SUB [01111h], DX
        CMP SI, [01111h]        ; Сравнивает два операнда - сравнивает текущее смешение с его концом
        JG END_LOOP2_0DD        ; Переход если первый операдн больше или равен второму -> SI>= CD-DX | IF SF=0F 
        MOV AX, [BP+SI]         ; записывает в AX значение из массива
        CMP AX, [BP+SI+2]       ; Сравнивает операнд массива и след его значение 
        JLE NO_SWAP_ODD         ; Переход если первый операнд меньше или равен второму -> AX<=[BP+SI+2] | IF SF!=OF OR ZF=1
        XCHG AX, [BP+SI+2]      ; Меняет местами операнды
        MOV [BP+SI], AX         ; Записывает большее значение в массив
        MOV BX, 1               ; записываем 1 - значит пеерстановка была
        NO_SWAP_ODD:
        ADD SI, 2               ; прибавляем 2, чтобы дальше идти по массиву
        JMP LOOP2_ODD           ; Переход на метку без условия 
    END_LOOP2_0DD:
    CMP BX, 1                   ; если в BX 1 или нет
    JE LOOP1_ODD                ; Если BX=1, то переходим в метку LOOP1 | IF ZF=1
    JMP NEXT_ARRAY_SORT_EVEN
NO_LOOP_ODD:     

; ===============================     
; SORT ARRAY EVEN
; ===============================
      
NEXT_ARRAY_SORT_EVEN:    
MOV CX, [count_even]            ; количество значений в массиве 
CMP CX, 0                       ; сравнивает количество значений в массиве с 0
JE NO_LOOP_EVEN:                ; если количество = 0, то пропускаем сортировку
MOV DX, 1                       ; счетчикдо какого элемента массива можно идти (с конца)
LOOP1_EVEN:
    MOV BX, 0                   ; проверка на то, была ли перестановка или нет
    MOV SI, 0                   ; индекс текущего элемента массива
    MOV BP, [addres_array_even] ; адрес начала массива      
    LOOP2_EVEN:
        MOV [01111h], CX
        SUB [01111h], DX
        CMP SI, [01111h]        ; Сравнивает два операнда - сравнивает текущее смешение с его концом
        JG END_LOOP2_EVEN       ; Переход если первый операдн больше или равен второму -> SI>= CD-DX | IF SF=0F 
        MOV AX, [BP+SI]         ; записывает в AX значение из массива
        CMP AX, [BP+SI+2]       ; Сравнивает операнд массива и след его значение 
        JGE NO_SWAP_EVEN        ; Переход если первый операнд меньше или равен второму -> AX<=[BP+SI+2] | IF SF!=OF OR ZF=1
        XCHG AX, [BP+SI+2]      ; Меняет местами операнды
        MOV [BP+SI], AX         ; Записывает большее значение в массив
        MOV BX, 1               ; записываем 1 - значит пеерстановка была
        NO_SWAP_EVEN:
        ADD SI, 2               ; прибавляем 2, чтобы дальше идти по массиву
        JMP LOOP2_EVEN          ; Переход на метку без условия 
    END_LOOP2_EVEN:
    CMP BX, 1                   ; если в BX 1 или нет
    JE LOOP1_EVEN               ; Если BX=1, то переходим в метку LOOP1 | IF ZF=1
NO_LOOP_EVEN:  

; ===============================     
; AVG VALUE 3
; ===============================
MOV AX, 0                       ; обнуляем регистры
MOV BX, 0                       ; обнуляем регистры
MOV BP, [addres_value_sum_3]    ; записываем в BP адрес где находится вся сумма значений
MOV AX, [BP]                    ; записываем в AX значения из адреса
MOV BX, [count_value_3]         ; записываем в BX количесвто этих значений
CMP BX, 0                       ; сравниваем количество с нулем
JE NO_IDIV_AVG                  ; если количество = 0, то пропускаем деление (на ноль делить нельзя)
IDIV BL                         ; делим сумму всех значений на количество
NO_IDIV_AVG:
    
END

