; Для массива из 12 16-разрядных чисел со знаком 
; разработать блок-схему алгоритма, программу на языке ассемблера 
; и в машинных кодах микропроцессора К1810ВМ86, 
; которая сортирует массив слов на четные и нечетные. 
; А также:
; располагает четные числа в порядке убывания модуля,
; располагает нечетные числа в порядке возрастания модуля,
; рассчитывает среднее арифметическое всех чисел, кратных 3.
; http://www.avprog.narod.ru/progs/emu8086/8086_instruction_set.html
 
 
ORG 100h                     ; начальный адрес программы

;array DW 2, -4, 1, -1, -6    ; массив для проверки         
;len_array DW 5               ; размер массива
array DW 1234h, 5678h, 9012h, 3456h, -7890h, -2345h, -6789h, 5432h, 9876h, -4321h, 8765h, -2109h
len_array DW 12

                       
count_even DW 0              ; количество четных элементов
addres_array_even DW 00010h  ; адрес для записи четных элементов
index_array_even DW 0        ; индекс текущего чеnного элемента массива
                
count_odd DW 0               ; количество нечетных элементов
addres_array_odd DW 00020h   ; адрес для записи нечетных элементов 
index_arrar_odd DW 0         ; индекс текущего нечетного элемента массива

count_value_3 DW 0           ; количество чисел, которые делятся на 3
addres_value_sum_3 DW 0F0F0h ; адрес для записи суммы чисел
MOV [0F0F0h], 0     
 
start:                
    MOV SI, 0             ; индекс текущего элемента массива
    MOV BP, 0             ; адрес начала массива  
    MOV CX, [len_array]   ; количество значений в массиве     
    OUTPUT:   
        MOV AX, array[SI] ; загрузка числа для проверки в регистр AX 
        TEST AX, 1        ; проверка на четность
        JNZ NUMBER_ODD    ; переход, если число нечетное   (ZF=0)
        JZ NUMBER_EVEN    ; переход, если число четное (ZF=1)          

    NUMBER_ODD:                     ; если число четное
         MOV DI, [index_arrar_odd]  ; записываем в DI значение индекса массива для четных
         MOV BP, [addres_array_odd] ; записываем в BP адресс массива для четных 
         MOV [BP+DI], AX            ; сохранение четного числа в массиве   
         ADD SI, 2                  ; переход к следующему элементу массива
         INC [count_odd]            ; увеличение количества четных чисел  
         ADD [index_arrar_odd], 2   ; увеличиваем индекс след значения массива для четных
    LOOP OUTPUT                     ; переходим в метку OUTPUT ЕСЛИ CX != 0
    JCXZ NEXT_ARRAY_SORT_ODD        ; если CX = 0, то идем дальше
      
    NUMBER_EVEN:                     ; если число нечетное
         MOV DI, [index_array_even]  ; записываем в DI значение индекса массива для нечетных
         MOV BP, [addres_array_even] ; записываем в BP адресс массива для нечетных   
         MOV [BP+DI], AX             ; сохранение четного числа в массиве   
         ADD SI, 2                   ; переход к следующему элементу массива
         INC [count_even]            ; увеличение количества четных чисел  
         ADD [index_array_even], 2   ; увеличиваем индекс след значения массива для нечетных
    LOOP OUTPUT                      ; переходим в метку OUTPUT ЕСЛИ CX != 0 
    JCXZ NEXT_ARRAY_SORT_ODD         ; если CX = 0, то идем дальше

; ===============================     
; SORT ARRAY ODD
; ===============================

NEXT_ARRAY_SORT_ODD:    
MOV CX, [count_odd]             ; количество значений в массиве 
CMP CX, 0                       ; сравнивает количество значений в массиве с 0
JE NO_LOOP_ODD:                 ; если количество = 0, то пропускаем сортировку
MOV DX, 1                       ; счетчикдо какого элемента массива можно идти (с конца)
LOOP1_ODD:
    MOV BX, 0                   ; проверка на то, была ли перестановка или нет
    MOV SI, 0                   ; индекс текущего элемента массива
    MOV BP, [addres_array_odd]  ; адрес начала массива      
    LOOP2_ODD:
        MOV [01111h], CX
        SUB [01111h], DX
        CMP SI, [01111h]        ; Сравнивает два операнда - сравнивает текущее смешение с его концом
        JG END_LOOP2_0DD        ; Переход если первый операдн больше или равен второму -> SI>= CD-DX | IF SF=0F 
        MOV AX, [BP+SI]         ; записывает в AX значение из массива
        CMP AX, [BP+SI+2]       ; Сравнивает операнд массива и след его значение 
        JL NO_SWAP_ODD         ; Переход если первый операнд меньше или равен второму -> AX<=[BP+SI+2] | IF SF!=OF OR ZF=1
        XCHG AX, [BP+SI+2]      ; Меняет местами операнды
        MOV [BP+SI], AX         ; Записывает большее значение в массив
        MOV BX, 1               ; записываем 1 - значит пеерстановка была
        NO_SWAP_ODD:
        ADD SI, 2               ; прибавляем 2, чтобы дальше идти по массиву
        JMP LOOP2_ODD           ; Переход на метку без условия 
    END_LOOP2_0DD:
    CMP BX, 1                   ; если в BX 1 или нет
    JE LOOP1_ODD                ; Если BX=1, то переходим в метку LOOP1 | IF ZF=1
    JMP NEXT_ARRAY_SORT_EVEN
NO_LOOP_ODD:     

; ===============================     
; SORT ARRAY EVEN
; ===============================
      
NEXT_ARRAY_SORT_EVEN:    
MOV CX, [count_even]            ; количество значений в массиве 
CMP CX, 0                       ; сравнивает количество значений в массиве с 0
JE NO_LOOP_EVEN:                ; если количество = 0, то пропускаем сортировку
MOV DX, 1                       ; счетчикдо какого элемента массива можно идти (с конца)
LOOP1_EVEN:
    MOV BX, 0                   ; проверка на то, была ли перестановка или нет
    MOV SI, 0                   ; индекс текущего элемента массива
    MOV BP, [addres_array_even] ; адрес начала массива      
    LOOP2_EVEN:
        MOV [01111h], CX
        SUB [01111h], DX
        CMP SI, [01111h]        ; Сравнивает два операнда - сравнивает текущее смешение с его концом
        JG END_LOOP2_EVEN       ; Переход если первый операдн больше или равен второму -> SI>= CD-DX | IF SF=0F 
        MOV AX, [BP+SI]         ; записывает в AX значение из массива
        CMP AX, [BP+SI+2]       ; Сравнивает операнд массива и след его значение 
        JG NO_SWAP_EVEN        ; Переход если первый операнд меньше или равен второму -> AX<=[BP+SI+2] | IF SF!=OF OR ZF=1
        XCHG AX, [BP+SI+2]      ; Меняет местами операнды
        MOV [BP+SI], AX         ; Записывает большее значение в массив
        MOV BX, 1               ; записываем 1 - значит пеерстановка была
        NO_SWAP_EVEN:
        ADD SI, 2               ; прибавляем 2, чтобы дальше идти по массиву
        JMP LOOP2_EVEN          ; Переход на метку без условия 
    END_LOOP2_EVEN:
    CMP BX, 1                   ; если в BX 1 или нет
    JE LOOP1_EVEN               ; Если BX=1, то переходим в метку LOOP1 | IF ZF=1
NO_LOOP_EVEN:  

; ===============================     
; AVG VALUE 3
; ===============================  
MOV SI, 0                        ; индекс текущего элемента массива
MOV BP, [addres_value_sum_3]     ; адрес где находится сумма значений  
MOV CX, [len_array]              ; количество значений в массиве  
MOV BX, 3                        ; пишем в BX его делитель    
AVG_OUTPUT:   
    MOV AX, array[SI]            ; загрузка числа для проверки в регистр AX 
    MOV DX, 0                    ; очищаем регистр DX
    TEST AX, 08000h              ; проверяем число отрицательное или нет
    JZ NO_NEGATIVE               ; если положительное, то пропускаем
    MOV DX, 0FFFFh               ; добавляем в DX -1, чтобы DX:AX было отрицательным
    NO_NEGATIVE:
    IDIV BX                      ; делим DX:AX на BX(3)
    CMP DX, 0                    ; проверяем есть ли остаток или нет
                       
    JNE NO_SUM3                  ; если остаток есть, то пропускаем часть, где заносим число
    INC [count_value_3]          ; прибавляем единицу счетчик   
    MOV DI, [addres_value_sum_3] ; записываем адрес памяти, в которой будет находится сумма всех чисел которые делятся на 3
    MOV AX, array[SI]            ; загрузка числа для проверки в регистр AX
    ADD [DI], AX                 ; суммируем число чтобы в памяти была сумма всех чисел которые делятся на 3 
    NO_SUM3:
    ADD SI, 2                    ; переход к следующему элементу массив 
LOOP AVG_OUTPUT
    
        
MOV AX, 0                       ; обнуляем регистры
MOV BX, 0                       ; обнуляем регистры
MOV BP, [addres_value_sum_3]    ; записываем в BP адрес где находится вся сумма значений
MOV AX, [BP]                    ; записываем в AX значения из адреса 
MOV DX, 0  

TEST AX, 08000h                 ; проверяем число отрицательное или нет
JZ NO_NEGATIVE_IDIV             ; если положительное, то пропускаем
MOV DX, 0FFFFh                  ; добавляем в DX -1, чтобы DX:AX было отрицательным
NO_NEGATIVE_IDIV: 

MOV BX, [count_value_3]         ; записываем в BX количесвто этих значений
CMP BX, 0                       ; сравниваем количество с нулем
JE NO_IDIV_AVG                  ; если количество = 0, то пропускаем деление (на ноль делить нельзя)
IDIV BX                         ; делим сумму всех значений на количество
NO_IDIV_AVG:

HLT    
END

